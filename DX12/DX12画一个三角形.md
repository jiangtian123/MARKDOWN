# DX12画一个三角形

## Device



### 1.DXGI创建

DXGI 是一种与Direct3D配合使用的API。它的功能是为了将一些通用的功能抽象出来给所有的DX系列的API使用，如2D渲染和3D渲染都需要创建窗口，需要创建交换链，找到显卡等功能不属于单独的一个图形管线的，就使用DXGI来创建。

```c++
ComPtr<IDXGIFactory5>				pIDXGIFactory5;
UINT nDXGIFactoryFlags = 0U;
CreateDXGIFactory2(nDXGIFactoryFlags, IID_PPV_ARGS(&pIDXGIFactory5);          
```

上诉代码演示了怎么创建一个DXGI。

### 2.寻找显示适配器

显示设备器是当前电脑拥有的显示设备，如显卡。通过DXGI可以枚举所有的显示设备器（一个电脑可以拥有多个显示设备器）。

```c++
//枚举显示设备器.
for (UINT adapterIndex = 1; DXGI_ERROR_NOT_FOUND != pIDXGIFactory5-EnumAdapters1(adapterIndex, &pIAdapter); ++adapterIndex)
		{
			DXGI_ADAPTER_DESC1 desc = {};
			pIAdapter->GetDesc1(&desc);
 
			if (desc.Flags & DXGI_ADAPTER_FLAG_SOFTWARE)
			{//跳过软件虚拟适配器设备
				continue;
			}
			//检查适配器对D3D支持的兼容级别，这里直接要求支持12.1的能力，注意返回接口的那个参数被置为了nullptr，这样
			//就不会实际创建一个设备了，也不用我们啰嗦的再调用release来释放接口。这也是一个重要的技巧，请记住！
			if (SUCCEEDED(D3D12CreateDevice(pIAdapter.Get(), D3D_FEATURE_LEVEL_12_1, _uuidof(ID3D12Device), nullptr)))
			{
				break;
			}
		}
```
 创建DX12设备

一个设备代表了一个显卡，可以这么粗暴理解吧

```c++
ComPtr<ID3D12Device4>				pID3DDevice;
GRS_THROW_IF_FAILED(D3D12CreateDevice(pIAdapter.Get(), D3D_FEATURE_LEVEL_12_1, IID_PPV_ARGS(&pID3DDevice)));
```

## GPU Resource

### 命令队列和命令列表
- CommandList
	命令列表，将一些GPU的命令添加进List里，随后调用**Close**关闭添加，再调用**ExecuteCommandList**来将命令列表添加进命令队列。
	
- CommandQueue 命令队列
	一个命令的缓冲区，存放一系列的命令列表。但是它里面的命令不会被立即执行，而是缓存起来。当命令队列被塞满后，CPU将不能向队列添加命令，只能等待GPU执行；同理如果队列为空，GPU将不工作，等待CPU传递命令。命令队列可以有很多种类型
	比如支持D3D12的GPU中至少就有执行3D命令的引擎，执行复制命令的引擎（就是从CPU内存中复制内容到显存中或反之或GPU内部以及引擎之间），执行通用计算命令的引擎（执行Computer Shader的引擎）以及可以进行视频编码解码的视频引擎等。而在D3D12中针对这些不同的引擎，就需要创建不同的命令队列接口来代表不同的引擎对象了。
	
	![](https://img-blog.csdn.net/2018091622501697?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQwMzgxNDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
	
- Command allocator
	存储命令的地方，真正分配内存的接口。

综上所述，可以将三者的关系看作，厨房（CommandQueue）真正做饭的地方,服务员（CommandList）只记录点的菜，记录菜名的纸（CommandAllocator），真正记录分配命令的地方。

```C++
D3D12_COMMAND_QUEUE_DESC stQueueDesc = {};
stQueueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
GRS_THROW_IF_FAILED(pID3DDevice->CreateCommandQueue(&stQueueDesc,IID_PPV_ARGS(&pICommandQueue)));
```



### 创建交换链
交换链相当于Opengl里的双缓冲，但是DX12里可以自由创建，三个都可以。

```c++
DXGI_SWAP_CHAIN_DESC1 stSwapChainDesc = {};
//创建的数量
		stSwapChainDesc.BufferCount = nFrameBackBufCount;
//长宽
		stSwapChainDesc.Width = iWidth;
		stSwapChainDesc.Height = iHeight;
//每个交换链的格式，这个是RGBA8
		stSwapChainDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
//
		stSwapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
		stSwapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
		stSwapChainDesc.SampleDesc.Count = 1;
 
		GRS_THROW_IF_FAILED(pIDXGIFactory5->CreateSwapChainForHwnd(
			pICommandQueue.Get(),		// Swap chain needs the queue so that it can force a flush on it.
			hWnd,
			&stSwapChainDesc,
			nullptr,
			nullptr,
			&pISwapChain1
		));
//得到当前缓冲区的序号，也就是下一个即将要呈送显示的缓冲区序号
GRS_THROW_IF_FAILED(pISwapChain1.As(&pISwapChain3));
nFrameIndex = pISwapChain3->GetCurrentBackBufferIndex();
```

### 创建描述符与描述符堆

- 描述符

  GPU在渲染的过程中需要各种资源，如顶点格式，矩阵，贴图，而描述符就是描述这种资源的轻量级结构体

  - CBV/SRV/UAV  常量缓冲区视图，着色器资源视图，无序访问视图。
  - sampler，采样器用于纹理贴图。
  - RTV 渲染目标视图资源
  - DSV 深度/模板视图资源

- 描述符堆指的是存放某种特定类型的描述符的一块内存。可以为每一种类型的描述符创建单独的描述符堆，也可以为同一种类型的描述符创建多个描述符堆

创建RTV（渲染目标视图)描述符堆(这里堆的含义应当理解为数组或者固定大小元素的固定大小显存池)
