# HLOD性能分系—XD场景

> 分析工具 ： SnapDragon Profiler
>
> 设备： 小米13U 高通骁龙8 gen。 八核。

## 没有HLOD，原始场景(带静态合批)

DC数量：595

处理的顶点数量：572823

总耗费时钟周期：4514137

## 去掉建筑（带静态合批）

DC数量：468

处理的顶点数：436578

总耗费时钟周期：3405074

## 对建筑应用HLOD（带静态合批）

DC数量：622	

处理的顶点数量：574527

总耗费时钟周期：4658913

## 没有HLOD，没有静态合批

DC：1085

Vertices: 573714

clocks: 6504570

## 带HLOD ，没有静态合批

DC : 1019

Vertices: 578640

clocks: 6293015

## 去掉建筑,无静态合批

DC：900

Vertices: 437469

Clocks: 5445679

## 去掉除建筑外所有物体，有HLOD

DC：131

Vertices:157917

Clocks:1302062

## 去掉处建筑外的所有物体，不带HLOD

DC：197

Vertices:153027

Clocks:1753204

## 去掉处建筑外的所有物体，静态合批

DC：141

Vertices：153027

Clocks: 1525857

## 重新梳理一下HLOD该怎么做

要想整理好HLOD，我认为需要从两个角度考虑。

- 第一个角度合批

  将多个实例**Instance**合并成一个DC，来提交。达到减少DC目的。并不会减少GPU的工作量。

- 第二角度是LOD

  根据**Instacne**在屏幕上的渲染占比来控制渲染使用的Mesh和材质，通过减少三角形和降低渲染效果来降低GPU的负担。

这两个功能看起来是独立的功能，在Unity中也是相对独立的，一个是静态物体在打包时会根据材质和索引缓冲区的限制将多个**Instance**合并成一个，然后根据剔除结果提交DC。LOD是由美术人员提前制作好LOD0，1，2逐级递减的Mesh，然后使用LODGroup组件，将Mesh绑定到对应的Lod等级上并设置切换范畴，游戏在运行时就会切换。

**但是！但是！**，如果静态物体有LOD时，Unity该怎么去做静态合批呢?

### 静态合批

所谓静态合批，既是在编辑时，会把一个场景中的某些物体标记为Static(即在游戏运行时不会运动的物体)，随后，打包。引擎按照一定规则将多个Mesh的顶点数据和索引数据相继合并成大的。规则大致如下

- Mesh如果顶点索引达到上限，合并到下一批（Unity默认是16位，两个字节）

在渲染时，即使是静态合批，也可以执行剔除操作，CPU在提交渲染时，只要修改对应的Draw接口的索引缓冲的偏移值就可以。

所以，在不考虑LOD的静态合批中，以同材质举例，合并后的要维护的数据结构，除了合并的网格外，还有没有合并的网格用来做剔除（但感觉只要保留网格的包围盒即可）。还要维护一个合并网格中对应Instance的Index索引，用来做完剔除后，给API使用。

#### 带有LOD的呢

经过在Unity中的测试发现，即使是不同的材质，带有LOD的物体也会合并到一个大的Buffer中。

即不同等级的LOD和不同的Instance，会合并到一个Buffer中，但是某些情况会被破坏掉。

#### 所以，静态合批加LOD是如何运作的呢

场景如下图:

![](D:\Users\Administrator\Desktop\内存测试\Static.jpg)

上图是LOD0级别的场景，都切换至LOD1后，如下：

![](D:\Users\Administrator\Desktop\内存测试\LODStatic.jpg)

合并后的缓冲中的物体排列大致如下（物体从左到右的编号分别是a,b,c,d,e,下标代表LOD等级)

| $a_1$ | $b_1$ | $c_1$ | $d_1$ | *$e_1$* | $a_0$ | $b_0$ | $c_0$ | $d_0$ | $e_0$ |
| ----- | ----- | ----- | ----- | ------- | ----- | ----- | ----- | ----- | ----- |

第一个场景情况时：

只有一个DC，取缓冲中的后五个Instance。

第二个场景时：

还是只有一个DC，取前五个Instance。

但是当场景中，一部分显示LOD0，一部分显示LOD1时，整个合批就会被打乱，再加上剔除的结果，静态合批就会退化成SRP合批。

#### 结论

围绕着，**减少顶点数**，**减少DC**这两点来看，给同一个物体设置不同的LOD，是可以同时做到的，但是在大多数请款下，因为LOD的切换和剔除操作以及材质的不同，会导致静态合批退化成类似SRP。

### HLOD

使用四叉树来管理场景中的静态物体，给各个节点做静态合批。

将不同层级的LOD抽离出来单独合批，而不是像Unity那样，合到一起。

现在问题是，HLOD的性能和静态合批差距不大。根据看过的资料有提到，HLOD主要作用中远景的合批管理，下面更多的考虑中远景的情况。

HLOD应该用来弥补静态合批的不足，即静态合批会退化的问题，但是这样来看，HLOD又不可以做充分的剔除（特指遮挡剔除）操作，因为Mesh提前处理好后，HLOD并不能像静态合批那样做完遮挡剔除再提交。

且静态合批不做分层，将所有LOD级别的Mesh都合并，会导致缓冲中还没有放足够的物体就会塞满。

## 实验

<img src="D:\Users\Administrator\Desktop\内存测试\TestScene.jpg" style="zoom:80%;" />

无静态合批的DC数量为：**1178**

静态合批的DC数量为：**821**

HLOD的DC数量为：**500**

通过抓帧可以看到，开启静态合批后，虽然Mesh数据统一提交了，但是还是退化成了SRP。由于剔除，排序，切换LOD等问题。

HLOD要想有可观的表现，对于场景的处理很重要。HLOD主要解决的是静态合批退化的问题，但是HLOD还会带来显存增加的困扰，因为HLOD并不可以像静态合批那样做精细化的剔除操作，当HLOD生成，根据节点判断层级后，该节点内如果有十个物体，哪怕只能看到三个，也会同一提交给GPU去做。

## 资源的序列化与加载

HLOD构建的最后一步就是合并Mesh资源的序列化。

当按照一定的规则合并模型后，后续的操作大致如下：

- 序列化资源
- 加载资源至项目

前几个步骤处理好的数据如下：

1. 场景的八叉树

   每个节点存放的是自己这个节点能容下的**Instance**，该**Instance**是引用的层级面板的实例。

2. BuidlInfo

   这个里面存放的是每个节点所有**Instane**的最低等级Mesh的合并，还有碰撞体。父节点会包含子节点的物体。

   空的节点会被删除

### 非流式加载

1. 将BulidInfo中的数据以二进制的方式序列化到磁盘中
2. 将资源从磁盘中导入到项目，这一步会在导入的时候，生成对应节点的**Instance**挂载到层级面板上
3. 将第二部生成好的节点挂到HLOD上，同时加一个HLODController组件用来在运行时控制HLOD层级的切换。
4. 根据每个合并节点取对应在四叉树中的节点，随后从节点里保存的原始**Instance**构建为这个节点的HIGHOBJ，合并节点的Mesh为LOWOBj。

以上就会把运行时需要的物体都挂载到场景信息上，在场景加载时，会从项目的Asset中把所有用到的资源都加载到内存中，根据HLOD的Container来控制一个节点显示为HIGH还是LOW。

节点只保存**HIGH和LOW **  OBJ的索引（list中的位置），实际上的Instance是保存在List中的。

#### 运行时

每个节点有三个状态，每种状态的切换都会回调对应的方法，来加载或者卸载资源。这个过程在相机的剔除前发生，由根节点开始依次向下开始更新。

- Release

  当前节点不可见

  当前节点如果距离相机超过了预设值或者父节点为Release和LOW，就会被剔除，从而设置为Release，不会被显示。

  当前资源都被加载进了内存，不显示只是将Instance设置为失活状态。

- HIGH

  如果一个节点为**HIGH**，则其管理的所有**Instance**显示，为非合批状态。这里有一个问题，既是有一些**Instacne**因为在四叉树的分割线上，不能进入小的包围盒，而进入了最大那个包围盒，当大包围盒状态为High时，不管**Instance**距离多远都会显示高模，但是由于这个脚本在处理时，并不会将LODGroup从实例上拿掉，所以这个情况不会发生，只是少了合批状态而已。

  如果用质点作为判断一个实例是否在该包围盒内的标准就会出现一个问题，即这样以来，每个物体都会存放到最叶子节点，导致非叶子节点不会有高模存在，而出现问题，本来距离很近的物体显示成为了低模。

- LOW

  当一个节点判断为LOW时，就会显示其保存的合并的Mesh，来自于它的所有的子节点，同时它的子节点被隐藏。

每个节点有几个状态，分别是：

- ExprectedState

  该状态是当前帧计算出来的状态

- CurrentState

  在期望状态没出来前，当前的状态

- LastState

  切换状态时，改变为要切换的状态，如果和当前状态不一致就回调状态改变函数

- TransactionTargetate

  转换状态时，切换当前帧要转换的那个状态。没转换时，为上一次转换的状态。

#### LoadOBJ

一个节点的状态变换不可以是跳跃式的，如从Realse直接到High，需要先到Low，在到HIGH。初始化时，全部默认为Realse。

1. 准备进入LOW

   将该节点下的LowObj加载到m_loadedLowObjects 中，如果其为null则New一个新的，如果已经加载过了则直接退出。

   上诉如果都没有的话，则根据自己保存的Low的id，去Controller中获取LowObj。

2. 判断是否进入成功

   只要load进来的物体个数等于节点保存的索引数量即为成功

3. 进入Low后

   交换m_lowObjects和m_loadedLowObjects引用，同时将m_loadedLowObjects设置为null，将子节点设置为Release。

4. 退出LOW

   将m_lowObjects保存的物体失活，同时清空。

5. 准备进入HIGH

   将子节点都设置为LOW。

   Load进来High的Obj，以Handle方式。

   将Load的Obj设置为False，

### 流式加载

两个组件

- AddressableStreaming

  用来Build合并好的资源。使用Addressable来做包管理，只保存地址。

- Controller

  负责加载和卸载资源，加载就是通过地址加载进内存进行实例化，卸载就将其释放掉。非流式加载的加载和卸载方式就是通过将实体的激活和失活做到的

### 几个数据结构的作用

- SapceNode 

  四叉树，只记录每个节点保存的Instance，场景处理过程中的数据容器

- HLODBuildInfo

  只记录合并的Mesh和其对应的节点，是按照层序遍历展开的四叉树，但是去掉了空节点，越靠前的四叉树越距离根节点近，同时也连同子节点的物体一起合并了。

- HLODTreeNodeContainer

  按照层展开的四叉树，其作用和上面那个及其类似。

- HLODTreeNode

  实际管理显示的节点，其中只存放该节点物体的索引，更多的作用在管理一个节点的状态。

- HLODData

  序列化合批模型的数据结构，保存合批的Mesh和碰撞体，是序列化好的。需要专门写Importer方法来导入

- RootData

  HLODData需要转为预制体保存，该节点就是保存预制体的。

