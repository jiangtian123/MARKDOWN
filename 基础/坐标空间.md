# 坐标空间

主要是记录以下不同API之间坐标空间的不同。

之前做TAA时就遇到了深度坐标空间在不同API之间方向不一致导致的重建UV的问题，现在做后处理也遇到了这个问题，现在记录以下，以后再遇到直接看笔记。

## 世界坐标空间

该坐标空间与API无关，主要用来统一以下各个物体的相对位置，但是世界坐标系分左手坐标系和右手坐标系，两者的不同反映在Z轴上。

以我们人眼为原点

- 左手坐标系的Z轴的正方向，与我们视线方向一致。
- 右手坐标系的Z轴的正方向，指向我们。

![](https://img-blog.csdnimg.cn/20200723105834738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTY0OTA4,size_16,color_FFFFFF,t_70)

在Unity中，世界坐标空间采用的是左手坐标系，Z轴正方向指向屏幕里，也就是和我们视线的方向一致。相机也是看向正方向的。

## 相机坐标空间

相机坐标空间影响到**View**矩阵。

相机空间也分左右手。

View矩阵的推导，得定义一个相机三个变量：

- 位置 e，相机在世界坐标中的位置。

- 朝向 g，相机在世界坐标中朝哪个位置看。

  在右手空间下，相机看向负方向，即(0,0,-1),在左手坐标下，相机看向正方向(0,0,+1)。

- 向上的方向 t，相机在世界坐标中Y轴的方向。

### 右手坐标系下的View矩阵

在右手坐标系下，相机看向负方向，即(0,0,-1)。所有的物体都在以相机为原点的负轴上。

#### 世界坐标系为右手系
##### 例一
定义相机的三个参数：

- e:$vec(0,0,3)$
- g:看向原点O = $vec(0,0,0)$,因为相机Z轴方向与世界坐标轴一致，所以$g= vec(e-O) = vec(0,0,3)$
- t:$vec(0,1,0)$

$X = t\times g = vec(0,1,0) \times vec(0,0,3) = vec(3,0,0)$,归一化后 $X = vec(1,0,0)$

$Y = g \times X = vec(0,0,1)\times vec(1,0,0) = vec(0,1,0)$

Z = $vec(0,0,1)$

所以$Matrix_{View} = 
\left[ \begin{matrix} 1&0&0&0  \\0&1&0&0 \\0&0&1&-3\\0&0&0&1 \end{matrix}\right] = \left[\begin{matrix} 1&0&0&0  \\0&1&0&0 \\0&0&1& 0\\0&0&0&1 \end{matrix}\right] \left[\begin{matrix} 1&0&0&0  \\0&1&0&0 \\0&0&1&-3\\0&0&0&1 \end{matrix}\right] \tag{1}
$ 

点$P = vec(0,0,1)$在相机空间的坐标为 $vec(0,0,-2)$
##### 例二
定义相机的三个参数：

- e:$vec(0,0,- 3)$
- g:看向原点O = $vec(0,0,0)$,则$g= vec(e-O) = vec(0,0,-3)$
- t:$vec(0,1,0)$

$X = t\times g = vec(0,1,0) \times vec(0,0,- 3) = vec(-3,0,0)$,归一化后 $X = vec(-1,0,0)$

$Y = g \times X = vec(0,0,1)\times vec() = vec(0,1,0)$

Z = $vec(0,0,-1)$

所以$Matrix_{View} = 
\left[ \begin{matrix} -1&0&0&0  \\0&1&0&0 \\0&0&-1&-3\\0&0&0&1 \end{matrix}\right] = \left[\begin{matrix} -1&0&0&0  \\0&1&0&0 \\0&0&-1& 0\\0&0&0&1 \end{matrix}\right] \left[\begin{matrix} 1&0&0&0  \\0&1&0&0 \\0&0&1&3\\0&0&0&1 \end{matrix}\right] \tag{1}
$ 

点$P = vec(0,0,1)$在相机空间的坐标为 $vec(0,0,-4)$

<img src="D:\Users\Administrator\Desktop\内存测试\rightView.jpg" style="zoom:80%;" />

绿色为例一，红色为例二。

#### 世界坐标系为左手系

先计算相机坐标系为为左手系的情况。
##### 例一
定义相机的三个参数：

- e:$vec(0,0,-3)$
- g:看向原点O = $vec(0,0,0)$,这时，$g= vec(O-e) = vec(0,0,3)$,归一化为$ver(0,0,1)$
- t:$vec(0,1,0)$

$X = t \times g = vec(0,1,0) \times vec(0,0,1) = vec(1,0,0)$,归一化后 $X = vec(1,0,0)$

$Y = X \times g = vec(1,0,0)\times vec(0,0,-1) = vec(0,1,0)$

Z = $vec(0,0,1)$

所以$Matrix_{View} = 
\left[ \begin{matrix} 1&0&0&0  \\0&1&0&0 \\0&0&1&3\\0&0&0&1 \end{matrix}\right] = \left[\begin{matrix} 1&0&0&0  \\0&1&0&0 \\0&0&1& 0\\0&0&0&1 \end{matrix}\right] \left[\begin{matrix} 1&0&0&0  \\0&1&0&0 \\0&0&1&3\\0&0&0&1 \end{matrix}\right] \tag{1}
$ 

点$P = vec(0,0,1)$在相机空间的坐标为 $vec(0,0,4)$

我们这时把旋转矩阵的Z轴取反，就可以在左手坐标系下得到右手坐标系的View矩阵了。
$Matrix_{View} = 
\left[ \begin{matrix} 1&0&0&0  \\0&1&0&0 \\0&0&-1&-3\\0&0&0&1 \end{matrix}\right] = \left[\begin{matrix} 1&0&0&0  \\0&1&0&0 \\0&0&-1& 0\\0&0&0&1 \end{matrix}\right] \left[\begin{matrix} 1&0&0&0  \\0&1&0&0 \\0&0&1&3\\0&0&0&1 \end{matrix}\right] \tag{1}
$ 

##### 例二
同理。

## 裁剪空间

经过上面的一系列变换，物体已经从Model坐标系变换到了相机坐标系下。

变换到裁剪空间的矩阵被称为投影矩阵。又分为**透视投影**和**正交投影**

正交投影就是将一个立方体视锥范围内的物体变换到NDC空间。

![](https://pic2.zhimg.com/80/v2-a6a509afb79c732686b1aa02df0eec1d_1440w.webp)

关于NDC空间，OpenGL，Metal，DX，都是Y轴向上如左图，但是VK是朝下的如右图。

除OpenGl的Z取值范围为[-1,1]外，其余都是[0-1]。

OpenGl的FrameBuffer空间（一个2D空间）的原点在左下角，其余的都在左上角。

纹理空间采样（0，0）时，采样的是左上角，所以OpenGl下，纹理往往要Flip Y以下。

## Unity

Unity中，坐标空间在来回转换。

世界空间是：左手

View: 右手

NDC：左手
